category: IT Services
commonfields:
  id: DNS
  version: -1
configuration:
- additionalinfo: DNS Server Address
  display: Server Address
  name: server
  required: true
  type: 0
- additionalinfo: Use TSIG key name to authenticate against DNS `server'
  display: TSIG Key Name
  name: key_name
  required: false
  type: 0
- additionalinfo: Use TSIG key secret, associated with `key_name', to authenticate
    against `server'
  display: TSIG Key Secret
  name: key_secret
  required: false
  type: 4
description: Manage DNS records using NSUpdate
display: DNS
name: DNS
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      default: true
      defaultValue: present
      description: Manage DNS record.
      name: state
      predefined:
      - present
      - absent
    - default: true
      defaultValue: '53'
      description: Use this TCP port when connecting to `server`.
      name: port
    - auto: PREDEFINED
      default: true
      defaultValue: hmac-md5
      description: Specify key algorithm used by `key_secret`.
      name: key_algorithm
      predefined:
      - HMAC-MD5.SIG-ALG.REG.INT
      - hmac-md5
      - hmac-sha1
      - hmac-sha224
      - hmac-sha256
      - hmac-sha384
      - hmac-sha512
    - description: 'DNS record will be modified on this `zone`.

        When omitted DNS will be queried to attempt finding the correct zone.

        Starting with Ansible 2.7 this parameter is optional.'
      name: zone
    - description: Sets the DNS record to modify. When zone is omitted this has to
        be absolute (ending with a dot).
      name: record
      required: true
    - default: true
      defaultValue: A
      description: Sets the record type.
      name: type
    - default: true
      defaultValue: '3600'
      description: Sets the record TTL.
      name: ttl
    - description: Sets the record value.
      name: value
    - auto: PREDEFINED
      default: true
      defaultValue: tcp
      description: Sets the transport protocol (TCP or UDP). TCP is the recommended
        and a more robust option.
      name: protocol
      predefined:
      - tcp
      - udp
    description: Manage DNS records.
    name: dns_nsupdate
    outputs: []
  dockerimage: demisto/ansible-runner
  runonce: false
  script: "\nimport json\nimport traceback\nimport ansible_runner\nimport ssh_agent_setup\n\
    from typing import Any, Dict, Tuple, List, Optional, Union, cast\n\n\n# Dict to\
    \ Markdown Converter adapted from https://github.com/PolBaladas/torsimany/\ndef\
    \ dict2md(json_block, depth=0):\n\tmarkdown = \"\"\n\tif isinstance(json_block,\
    \ dict):\n\t    markdown = parseDict(json_block, depth)\n    if isinstance(json_block,\
    \ list):\n\t    markdown = parseList(json_block, depth)\n\treturn markdown\n\n\
    \ndef parseDict(d, depth):\n\tmarkdown = \"\"\n\tfor k in d:\n\t\tif isinstance(d[k],\
    \ (dict, list)):\n\t\t\tmarkdown += addHeader(k, depth)\n\t\t\tmarkdown += dict2md(d[k],\
    \ depth + 1)\n\t\telse:\n\t\t\tmarkdown += buildValueChain(k, d[k], depth)\n\t\
    return markdown\n\ndef parseList(l, depth):\n\tmarkdown = \"\"\n\tfor value in\
    \ l:\n\t\tif not isinstance(value, (dict, list)):\n\t\t\tindex = l.index(value)\n\
    \t\t\tmarkdown += buildValueChain(index, value, depth)\n\t\telse:\n\t\t\tmarkdown\
    \ += parseDict(value, depth)\n\treturn markdown\n\ndef buildHeaderChain(depth):\n\
    \tlist_tag = '* '\n\thtag = '#'\n\n\tchain = list_tag * (bool(depth)) + htag *\
    \ (depth + 1) + \\\n\t\t' value ' + (htag * (depth + 1) + '\\n')\n\treturn chain\n\
    \ndef buildValueChain(key, value, depth):\n\ttab = \"  \"\n\tlist_tag = '* '\n\
    \n\tchain = tab * (bool(depth - 1)) + list_tag + \\\n\t\tstr(key) + \": \" + str(value)\
    \ + \"\\n\"\n\treturn chain\n\ndef addHeader(value, depth):\n\tchain = buildHeaderChain(depth)\n\
    \tchain = chain.replace('value', value.title())\n\treturn chain\n\n\n# Remove\
    \ ansible branding from results\ndef rec_ansible_key_strip(obj):\n    if isinstance(obj,\
    \ dict):\n        return {key.replace('ansible_', ''): rec_ansible_key_strip(val)\
    \ for key, val in obj.items()}\n    return obj\n\n\n\n# COMMAND FUNCTIONS\n\n\n\
    def generic_ansible(integration_name, command, args: Dict[str, Any]) -> CommandResults:\n\
    \n    readable_output = \"\"\n    sshkey = \"\" \n    fork_count = 1   # default\
    \ to executing against 1 host at a time\n\n    if args.get('concurrency'):\n \
    \       fork_count = int(args.get('concurrency'))\n\n    inventory = {}\n    inventory['all']\
    \ = {}\n    inventory['all']['hosts'] = {}\n    \n    inventory['all']['hosts']['localhost']\
    \ = {}\n    inventory['all']['hosts']['localhost']['ansible_connection'] = 'local'\n\
    \            \n    module_args = \"\"\n    # build module args list\n    for arg_key,\
    \ arg_value in args.items():\n        # skip hardcoded host arg, as it doesn't\
    \ related to module\n        if arg_key == 'host':\n            continue\n\n \
    \       module_args += \"%s=\\\"%s\\\" \" % (arg_key, arg_value)\n    # If this\
    \ isn't host based, then all the integratation parms will be used as command args\n\
    \    for arg_key, arg_value in demisto.params().items():\n        module_args\
    \ += \"%s=\\\"%s\\\" \" % (arg_key, arg_value)\n\n        \n\n    r = ansible_runner.run(inventory=inventory,host_pattern='all',\
    \ module=command, quiet=True, omit_event_data=True, ssh_key=sshkey, module_args=module_args,\
    \ forks=fork_count)\n\n    results = []\n    for each_host_event in r.events:\n\
    \        # Troubleshooting\n        # demisto.log(\"%s: %s\\n\" % (each_host_event['event'],\
    \ each_host_event))\n        if each_host_event['event'] in (\"runner_on_ok\"\
    , \"runner_on_unreachable\", \"runner_on_failed\"):\n\n            # parse results\n\
    \n            result = json.loads('{' + each_host_event['stdout'].split('{',1)[1])\n\
    \            host = each_host_event['stdout'].split('|',1)[0].strip()\n      \
    \      status = each_host_event['stdout'].replace('=>', '|').split('|',3)[1]\n\
    \n            # if successful build outputs\n            if each_host_event['event']\
    \ == \"runner_on_ok\":\n                if 'fact' in command:\n              \
    \      result = result['ansible_facts']\n                else:\n             \
    \       if result.get(command) != None:\n                        result = result[command]\n\
    \                    else:\n                        result.pop(\"ansible_facts\"\
    , None)\n\n                result = rec_ansible_key_strip(result)\n\n        \
    \        if host != \"localhost\":\n                    readable_output += \"\
    # %s - %s\\n\" % (host, status)\n                else:\n                    #\
    \ This is integration is not host based\n                    readable_output +=\
    \ \"# %s\\n\" % status\n\n                readable_output += dict2md(result)\n\
    \n                # add host and status to result\n                result['host']\
    \ = host\n                result['status'] = status\n\n                results.append(result)\n\
    \            if each_host_event['event'] == \"runner_on_unreachable\":\n     \
    \           msg = \"Host %s unreachable\\nError Details: %s\" % (host, result)\n\
    \                return_error(msg)\n\n            if each_host_event['event']\
    \ == \"runner_on_failed\":\n                msg = \"Host %s failed running command\\\
    nError Details: %s\" % (host, result)\n                return_error(msg)\n   \
    \ # This is integration is not host based and always runs against localhost\n\
    \    results = results['localhost']\n    \n    return CommandResults(\n      \
    \  readable_output=readable_output,\n        outputs_prefix=integration_name +\
    \ '.' + command,\n        outputs_key_field='',\n        outputs=results\n   \
    \ )\n\n\n\n# MAIN FUNCTION\n\n\ndef main() -> None:\n    \"\"\"main function,\
    \ parses params and runs command functions\n\n    :return:\n    :rtype:\n    \"\
    \"\"\n\n    # SSH Key integration requires ssh_agent to be running in the background\n\
    \    ssh_agent_setup.setup()\n\n    try:\n\n        if demisto.command() == 'test-module':\n\
    \            # This is the call made when pressing the integration Test button.\n\
    \            return_results('ok')\n        elif demisto.command() == 'dns_nsupdate':\n\
    \            return_results(generic_ansible('dns', 'nsupdate', demisto.args()))\n\
    \    # Log exceptions and return errors\n    except Exception as e:\n        demisto.error(traceback.format_exc())\
    \  # print the traceback\n        return_error(f'Failed to execute {demisto.command()}\
    \ command.\\nError:\\n{str(e)}')\n\n\n# ENTRY POINT\n\n\nif __name__ in ('__main__',\
    \ '__builtin__', 'builtins'):\n    main() "
  subtype: python3
  type: python
